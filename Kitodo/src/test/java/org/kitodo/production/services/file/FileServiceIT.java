/*
 * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>
 *
 * This file is part of the Kitodo project.
 *
 * It is licensed under GNU General Public License version 3 or later.
 *
 * For the full copyright and license information, please read the
 * GPL3-License.txt file that was distributed with this source code.
 */

package org.kitodo.production.services.file;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URI;
import java.nio.channels.FileLock;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.kitodo.MockDatabase;
import org.kitodo.TreeDeleter;
import org.kitodo.api.dataformat.MediaVariant;
import org.kitodo.api.dataformat.PhysicalDivision;
import org.kitodo.api.dataformat.Workpiece;
import org.kitodo.config.ConfigCore;
import org.kitodo.config.enums.ParameterCore;
import org.kitodo.data.database.beans.Process;
import org.kitodo.data.database.exceptions.DAOException;
import org.kitodo.production.helper.metadata.ImageHelper;
import org.kitodo.production.services.ServiceManager;
import org.kitodo.production.thread.RenameMediaThread;
import org.kitodo.test.utils.ProcessTestUtils;

public class FileServiceIT {
    /**
     * One of the directories that are generated by the test and later deleted.
     */
    private static final String SEVERAL = "several";
    private static final String TEST_RENAME_MEDIA_FILE = "testRenameMediaMeta.xml";
    private static final String RENAME_MEDIA_PROCESS_1 = "renameMediaProcess1";
    private static final String RENAME_MEDIA_PROCESS_2 = "renameMediaProcess2";
    private static final String RENAME_MEDIA_REVERT_PROCESS = "revertMediaRenamingProcess";
    private static int mediaRenamingFirstProcessId = -1;
    private static int mediaRenamingSecondProcessId = -1;
    private static int revertMediaRenamingProcessId = -1;

    @BeforeAll
    public static void setUp() throws Exception {
        FileService fileService = new FileService();
        fileService.createDirectory(URI.create(""), "fileServiceTest");
        MockDatabase.startNode();
        MockDatabase.insertProcessesFull();
        MockDatabase.startDatabaseServer();
        MockDatabase.insertFoldersForSecondProject();
    }

    @AfterAll
    public static void tearDown() throws IOException {
        FileService fileService = new FileService();
        fileService.delete(URI.create("fileServiceTest"));
    }

    @Test
    public void testRenameFileWithLockedFile() throws IOException {
        FileService fileService = new FileService();
        URI oldUri = fileService.createResource(URI.create("fileServiceTest"), "oldName.xml");
        assertTrue(fileService.fileExist(oldUri));
        // Open stream to file and lock it, so it cannot be renamed
        FileOutputStream outputStream = new FileOutputStream(fileService.getFile(oldUri));
        try (outputStream) {
            FileLock fileLock = outputStream.getChannel().lock();
            fileService.renameFile(oldUri, "newName.xml");
            fileLock.close();
        } catch (IOException e) {
            URI newUri = URI.create("fileServiceTest/newName.xml");
            assertFalse(fileService.fileExist(newUri));
            assertTrue(fileService.fileExist(oldUri));
        }
    }

    @Test
    public void testCreateDirectories() throws IOException {
        ServiceManager.getFileService().createDirectories(URI.create("several/directories/can/be/created/at/once"));
        assertTrue(ServiceManager.getFileService().isDirectory(URI.create(SEVERAL)));
        cleanUp();
    }

    @Test
    public void testCreateDirectoriesWithTrailingSlash() throws IOException {
        ServiceManager.getFileService()
                .createDirectories(URI.create("several/directories/can/be/created/with/trailing/"));
        assertTrue(ServiceManager.getFileService().isDirectory(URI.create(SEVERAL)));
        cleanUp();
    }

    @Test
    public void testMetadataImageComparator() {
        MetadataImageComparator metadataImageComparator = ServiceManager.getFileService().getMetadataImageComparator();

        assertEquals(metadataImageComparator.compare("filename2", "filename1"), 1);

        assertEquals(metadataImageComparator.compare("0000001", "0000002"), -1);

        assertEquals(metadataImageComparator.compare("file.name.01", "file.name.02"),-1);

        assertEquals(metadataImageComparator.compare(
                new File("filename_01.tif").toURI(), new File("filename_02.tif").toURI()), -1);

        assertEquals(metadataImageComparator.compare(
                new File("0000001.tif").toURI(), new File("0000002.tif").toURI()), -1);

        assertEquals(metadataImageComparator.compare(
                new File("file.name.01.tif").toURI(), new File("file.name.02.tif").toURI()), -1);

    }

    @Test
    public void testRenamingOfMultipleProcesses() throws DAOException, IOException, InterruptedException {
        mediaRenamingFirstProcessId = MockDatabase.insertTestProcessIntoSecondProject(RENAME_MEDIA_PROCESS_1);
        mediaRenamingSecondProcessId = MockDatabase.insertTestProcessIntoSecondProject(RENAME_MEDIA_PROCESS_2);
        ProcessTestUtils.copyTestFiles(mediaRenamingFirstProcessId, TEST_RENAME_MEDIA_FILE);
        ProcessTestUtils.copyTestFiles(mediaRenamingSecondProcessId, TEST_RENAME_MEDIA_FILE);
        List<Process> testProcesses = new LinkedList<>();
        testProcesses.add(ServiceManager.getProcessService().getById(mediaRenamingFirstProcessId));
        testProcesses.add(ServiceManager.getProcessService().getById(mediaRenamingSecondProcessId));
        // 1. check filename & order values of both processes _before_ renaming
        assertFalse(mediaFilesNamedAccordingToOrderAttribute(mediaRenamingFirstProcessId));
        assertFalse(mediaFilesNamedAccordingToOrderAttribute(mediaRenamingSecondProcessId));
        // 2. perform media renaming
        RenameMediaThread renameMediaThread = new RenameMediaThread(testProcesses);
        renameMediaThread.start();
        renameMediaThread.join(3000);
        // 3. check filename & order values of both processes _after_ renaming
        assertTrue(mediaFilesNamedAccordingToOrderAttribute(mediaRenamingFirstProcessId));
        assertTrue(mediaFilesNamedAccordingToOrderAttribute(mediaRenamingSecondProcessId));
    }

    @Test
    public void testRevertingOriginalFilenamesAfterRenamingError() throws DAOException, IOException,
            InterruptedException {
        revertMediaRenamingProcessId = MockDatabase.insertTestProcessIntoSecondProject(RENAME_MEDIA_REVERT_PROCESS);
        ProcessTestUtils.copyTestFiles(revertMediaRenamingProcessId, TEST_RENAME_MEDIA_FILE);
        Path processScansDir = Paths.get(ConfigCore.getKitodoDataDirectory(), revertMediaRenamingProcessId
                + "/images/scans/").toAbsolutePath();
        // 1. delete last referenced image to provoke failed media renaming attempt
        Path lastImagePath = processScansDir.resolve("03.tif");
        ServiceManager.getFileService().delete(lastImagePath.toUri());
        // 2. determine filenames before failed media renaming attempt
        List<URI> scanURIsBeforeRenaming = ServiceManager.getFileService().getSubUris(ImageHelper.dataFilter,
                processScansDir.toUri()).stream().sorted().collect(Collectors.toList());
        // 3. perform failing media renaming
        Process process = ServiceManager.getProcessService().getById(revertMediaRenamingProcessId);
        RenameMediaThread renameMediaThread = new RenameMediaThread(Collections.singletonList(process));
        renameMediaThread.start();
        renameMediaThread.join(3000);
        // 4. determine filenames after failed media renaming attempt
        List<URI> scanURIsAfterRenaming = ServiceManager.getFileService().getSubUris(ImageHelper.dataFilter,
                processScansDir.toUri()).stream().sorted().collect(Collectors.toList());
        // 5. assert that filenames have been successfully reverted to originals after failed media renaming attempt
        assertEquals(scanURIsBeforeRenaming.size(), scanURIsAfterRenaming.size());
        for (int i = 0; i < scanURIsBeforeRenaming.size(); i++) {
            assertEquals(scanURIsBeforeRenaming.get(i).toString(), scanURIsAfterRenaming.get(i).toString());
        }
    }

    private boolean mediaFilesNamedAccordingToOrderAttribute(int processId) throws DAOException, IOException {
        Process process = ServiceManager.getProcessService().getById(processId);
        int filenameLength = process.getProject().getFilenameLength();
        for (PhysicalDivision page : getProcessPages(process)) {
            for (Map.Entry<MediaVariant, URI> mediaVariantURIEntry : page.getMediaFiles().entrySet()) {
                String basename = FilenameUtils.getBaseName(mediaVariantURIEntry.getValue().getPath());
                String expectedName = StringUtils.leftPad(String.valueOf(page.getOrder()), filenameLength, '0');
                if (!(Integer.parseInt(basename) == page.getOrder() && basename.equals(expectedName))) {
                    return false;
                }
            }
        }
        return true;
    }

    private static List<PhysicalDivision> getProcessPages(Process process) throws IOException {
        URI uri = ServiceManager.getProcessService().getMetadataFileUri(process);
        Workpiece workpiece = ServiceManager.getMetsService().loadWorkpiece(uri);
        return workpiece.getAllPhysicalDivisionChildrenSortedFilteredByPageAndTrack();
    }

    private void cleanUp() throws IOException {
        Path testBaseDirectoryPath = Paths.get(ConfigCore.getParameter(ParameterCore.DIR_PROCESSES));
        Path firstDirectoryOfTestPath = testBaseDirectoryPath.resolve(SEVERAL);
        TreeDeleter.deltree(firstDirectoryOfTestPath);
    }

    /**
     * Cleanup test resources and dummy processes after test completion.
     *
     * @throws Exception when removing process from database, index or filesystem fails.
     */
    @AfterAll
    public static void removeDummyAndTestProcesses() throws Exception {
        ProcessTestUtils.removeTestProcess(mediaRenamingFirstProcessId);
        ProcessTestUtils.removeTestProcess(mediaRenamingSecondProcessId);
        ProcessTestUtils.removeTestProcess(revertMediaRenamingProcessId);
        MockDatabase.stopNode();
        MockDatabase.cleanDatabase();
    }
}
