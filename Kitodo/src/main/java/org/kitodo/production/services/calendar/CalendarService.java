/*
 * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>
 *
 * This file is part of the Kitodo project.
 *
 * It is licensed under GNU General Public License version 3 or later.
 *
 * For the full copyright and license information, please read the
 * GPL3-License.txt file that was distributed with this source code.
 */

package org.kitodo.production.services.calendar;

import static org.kitodo.constants.StringConstants.CREATE;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.kitodo.api.dataeditor.rulesetmanagement.ComplexMetadataViewInterface;
import org.kitodo.api.dataeditor.rulesetmanagement.MetadataViewInterface;
import org.kitodo.api.dataeditor.rulesetmanagement.RulesetManagementInterface;
import org.kitodo.api.dataeditor.rulesetmanagement.SimpleMetadataViewInterface;
import org.kitodo.api.dataeditor.rulesetmanagement.StructuralElementViewInterface;
import org.kitodo.config.ConfigCore;
import org.kitodo.config.enums.ParameterCore;
import org.kitodo.data.database.beans.Process;
import org.kitodo.data.database.exceptions.DAOException;
import org.kitodo.production.forms.createprocess.ProcessDetail;
import org.kitodo.production.forms.createprocess.ProcessFieldedMetadata;
import org.kitodo.production.model.bibliography.course.Block;
import org.kitodo.production.model.bibliography.course.IndividualIssue;
import org.kitodo.production.model.bibliography.course.Issue;
import org.kitodo.production.model.bibliography.course.metadata.CountableMetadata;
import org.kitodo.production.model.bibliography.course.metadata.MetadataEditMode;
import org.kitodo.production.security.SecurityUserDetails;
import org.kitodo.production.services.ServiceManager;

public class CalendarService {

    /**
     * Returns a list of all individual issues for the given block.
     *
     * @param block the block to get all individual issues for
     * @return a list of the block's individual issues
     */
    public static List<IndividualIssue> getIndividualIssues(Block block) {
        List<IndividualIssue> individualIssues = new ArrayList<>();
        if (Objects.isNull(block.getFirstAppearance()) || Objects.isNull(block.getLastAppearance())) {
            return individualIssues;
        }
        for (LocalDate day = block.getFirstAppearance(); !day.isAfter(block.getLastAppearance()); day = day.plusDays(1)) {
            individualIssues.addAll(block.getIndividualIssues(day));
        }
        return individualIssues;
    }

    /**
     * Get all metadata allowed for the future elements that will be generated by the NewspaperProcessesGenerator.
     * This method uses the parent process to determine the allowed metadata by loading the corresponding ruleset.
     * It causes IO operations and thus the result should be cached if possible.
     *
     * @param completeEdition parent process
     * @return list of allowed metadata as SelectItem objects
     * @throws IOException when ruleset file could not be read
     */
    public static List<MetadataViewInterface> getAddableMetadata(Process completeEdition) throws IOException, DAOException {

        // get an instance of the ruleset module
        RulesetManagementInterface ruleset = ServiceManager.getRulesetManagementService().getRulesetManagement();

        // find and load the ruleset file
        String rulesetDir = ConfigCore.getParameter(ParameterCore.DIR_RULESETS);
        String rulesetFullPath = Paths.get(rulesetDir, completeEdition.getRuleset().getFile()).toString();
        ruleset.load(new File(rulesetFullPath));

        // get the userâ€™s metadata language
        SecurityUserDetails authenticatedUser = ServiceManager.getUserService().getAuthenticatedUser();
        List<Locale.LanguageRange> priorityList = Locale.LanguageRange.parse(authenticatedUser.getMetadataLanguage());

        // get the basic rule set type of the newspaper
        String newspaperType = ServiceManager.getProcessService().getBaseType(completeEdition.getId());

        // descend to the issue
        StructuralElementViewInterface newspaperView = ruleset.getStructuralElementView(newspaperType, CREATE, priorityList);
        String yearType = newspaperView.getAllowedSubstructuralElements().entrySet().iterator().next().getKey();

        StructuralElementViewInterface yearView = ruleset.getStructuralElementView(yearType, CREATE, priorityList);
        String monthType = yearView.getAllowedSubstructuralElements().entrySet().iterator().next().getKey();

        StructuralElementViewInterface monthView = ruleset.getStructuralElementView(monthType, CREATE, priorityList);
        String dayType = monthView.getAllowedSubstructuralElements().entrySet().iterator().next().getKey();

        StructuralElementViewInterface dayView = ruleset.getStructuralElementView(dayType, CREATE, priorityList);
        String issueType = dayView.getAllowedSubstructuralElements().entrySet().iterator().next().getKey();

        StructuralElementViewInterface issueView = ruleset.getStructuralElementView(issueType, CREATE, priorityList);

        // From view to output, get all addable metadata
        return new ArrayList<>(issueView.getAllowedMetadata())
                .stream().sorted(Comparator.comparing(MetadataViewInterface::getLabel)).collect(Collectors.toList());
    }

    /**
     * Get translation for a metadata type.
     * The key will be used to find the metadata in the given list of SelectItem objects and retrieve the translation.
     *
     * @param metadataList list of all allowed metadata
     * @param metadataKey the key for the metadata type to be translated
     * @return localized metadata type as java.lang.String
     */
    public static String getMetadataTranslation(List<ProcessDetail> metadataList, String metadataKey) {
        for (ProcessDetail selectItem : metadataList) {
            if (selectItem.getMetadataID().equals(metadataKey)) {
                return selectItem.getLabel();
            }
        }
        throw new IllegalArgumentException("The key \"" + metadataKey + "\" was not found in the list of metadata.");
    }

    /**
     * Get list of metadata for given block on a specific date and issue.
     *
     * @param block the block to get the metadata from
     * @param date the date to get the metadata for
     * @param issue the issue to get the metadata for
     * @return list of matching metadata
     */
    public static List<CountableMetadata> getMetadata(Block block, LocalDate date, Issue issue) {
        if (Objects.nonNull(block)) {
            List<CountableMetadata> metadata = new ArrayList<>();
            for (CountableMetadata countableMetadata :  block.getMetadata()) {
                MetadataEditMode editMode = countableMetadata.getEditMode(new ImmutablePair<>(date, issue));
                if (Objects.nonNull(editMode) && !MetadataEditMode.HIDDEN.equals(editMode)) {
                    if (countableMetadata.getCreate().getRight()) {
                        if (Objects.equals(countableMetadata.getCreate().getMiddle(), issue)) {
                            metadata.add(countableMetadata);
                        }
                    } else {
                        metadata.add(countableMetadata);
                    }
                }
            }
            return metadata;
        }
        return Collections.emptyList();
    }

    /**
     * Get all metadata of the given block as summary.
     * Each type of metadata is only listed once with its earliest occurrence.
     *
     * @param block the block to get the metadata for
     * @return list of pairs containing the metadata type and the date of its earliest occurrence
     */
    public static List<Pair<ProcessDetail, LocalDate>> getMetadataSummary(Block block) {
        Map<ProcessDetail, LocalDate> metadataMap = new HashMap<>();
        if (Objects.nonNull(block)) {
            for (CountableMetadata metadata : block.getMetadata()) {
                if (metadataMap.containsKey(metadata.getMetadataDetail())) {
                    if (metadata.getCreate().getLeft().isBefore(metadataMap.get(metadata.getMetadataDetail()))) {
                        metadataMap.replace(metadata.getMetadataDetail(), metadata.getCreate().getLeft());
                    }
                } else {
                    metadataMap.put(metadata.getMetadataDetail(), metadata.getCreate().getLeft());
                }
            }
        }
        return metadataMap.entrySet().stream()
                .map(e -> new ImmutablePair<>(e.getKey(), e.getValue()))
                .collect(Collectors.toList());
    }

    /**
     * Converts a pair of date and issue to a human-readable string.
     *
     * @param dateIssue the pair of date and issue to be formatted
     * @return human-readable string
     */
    public static String dateIssueToString(Pair<LocalDate, Issue> dateIssue) {
        if (Objects.isNull(dateIssue) || Objects.isNull(dateIssue.getLeft())) {
            return "";
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(DateTimeFormatter.ISO_DATE.format(dateIssue.getLeft()));
        if (Objects.nonNull(dateIssue.getRight()) && !dateIssue.getRight().getHeading().isEmpty()) {
            stringBuilder.append(", ");
            stringBuilder.append(dateIssue.getRight().getHeading());
        }
        return stringBuilder.toString();
    }

    /**
     * Get all metadata allowed for the future elements that will be generated
     * by the NewspaperProcessesGenerator.
     *
     * @param completeEdition parent process
     * @return list of allowed metadata as List of ProcessDetail
     * @throws IOException when ruleset file could not be read
     */
    public static List<ProcessDetail> getAddableMetadataTable(Process completeEdition) throws IOException, DAOException {
        ProcessFieldedMetadata table = new ProcessFieldedMetadata();
        List<MetadataViewInterface> metadataViewInterfaceList = getAddableMetadata(completeEdition);
        for (MetadataViewInterface keyView : metadataViewInterfaceList) {
            if (keyView.isComplex()) {
                table.createMetadataGroupPanel((ComplexMetadataViewInterface) keyView, Collections.emptyList());
            } else {
                table.createMetadataEntryEdit((SimpleMetadataViewInterface) keyView, Collections.emptyList());
            }
        }
        return table.getRows();
    }
}
